---
description: C# Bridge DLL setup for native context extraction and WebView2 hosting
complexity: ðŸ”´ Complex
---

# 4. C# Bridge DLL and Context Extraction

This plan lays the groundwork for the C# Class Library (`.dll`) that sits between the legacy native desktop application, the WebView2 React UI, and the Python backend.

## Objectives
- Scaffold a C# Class Library project (`.csproj`).
- Define the `IContextExtractor` interfaces for extracting active screen details.
- Define the Native-to-WebView2 messaging bridge pattern.

---

## Execution Steps

### Step 1: Initialize C# Project
- Navigate to `src/client/csharp-bridge/`
- Run `dotnet new classlib -n EngRAG.Bridge -f net8.0` (or target framework appropriate for the existing app).
- Create a solution file (`dotnet new sln`) and add the project to it.

### Step 2: Context Extraction Interfaces
- In the new project, create `ContextExtractors/IContextExtractor.cs`.
- Define an interface method: `Task<string> GetCurrentApplicationStateAsync()`.
- Create a mock implementation `ContextExtractors/MockManufacturingContext.cs` that returns JSON representing a fake active screen (e.g., `{"active_module": "Equipment Selection", "selected_item": "PUMP-101", "unsaved_changes": true}`).

### Step 3: Action Execution Interfaces
- Create `ActionHandlers/IActionExecutor.cs`.
- Define a method: `Task<bool> ExecuteActionAsync(string actionName, string jsonPayload)`.
- This is what the React app will call (via the bridge) when the user clicks "Approve".

### Step 4: WebView2 Javascript Interop Skeleton
- Create `WebView2Host/BrowserBridge.cs`.
- Implement a class decorated for COM visibility / `WebMessageReceived` event handling, allowing the React JS app to call `window.chrome.webview.postMessage(...)` and trigger a native C# method.

---

## Validation / Testing
1. **Compilation:** Run `dotnet build` inside `src/client/csharp-bridge/EngRAG.Bridge`. The library must compile with zero errors.
2. **Interface Parity:** Ensure the namespace structures match the actual folders. 
*Note: Full end-to-end testing of this component will require integration with the actual host application later, but the API boundaries must be validated strictly during compilation here.*
